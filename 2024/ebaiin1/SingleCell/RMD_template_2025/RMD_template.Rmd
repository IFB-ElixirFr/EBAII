---
title: "<CENTER>EB3I n1 2025 scRNAseq<BR>-<BR> <B>LESSON BLOCK (I)</B><BR>-<BR>A nice subtitle</CENTER>"
date: "2025-16-21.22"
author:
  - name: "EBAII n1 scRNAseq Team"
  - name: "First AUTHOR"
    email: "first.author@scrnaseq.com"
  - name: "Second AUTHOR"
    email: "second.author@scrnaseq.com"
output:
  rmdformats::readthedown:
    fig_width: 8
    fig_height: 6
    highlight: tango  ## Theme for the code chunks
    embed_fonts: TRUE
    number_sections: true  ## Adds number to headers (sections)
    theme: flatly  ## CSS theme for the HTML page
    collapsed: true  ## By default, the TOC is folded
    toc_depth: 3
    smooth_scroll: true ## Smooth scroll of the HTML page
    self_contained: true ## Includes all plots/images within the HTML
    code_download: true ## Adds a button to download the Rmd
    code_folding: show
    thumbnails: false
    lightbox: true
    fig_caption: false
    gallery: true
    use_bookdown: true
always_allow_html: true ## Allow plain HTML code in the Rmd
editor_options: 
  markdown: 
    wrap: 72
---

<!-- knit setup -->

```{r knit_setup, echo = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,        # Print the code
  eval = TRUE,        # Run command lines
  message = FALSE,    # Print messages
  prompt = FALSE,     # Do not display prompt
  comment = NA,       # No comments on this section
  warning = FALSE,    # Display warnings
  tidy = FALSE,
  fig.align="center", 
  # results = 'hide',
  width = 100       # Number of characters per line
)
```


<!-- CSS to color chunks and outputs -->

```{css, echo=FALSE}
.notrun {
  background-color: lightgrey !important;
  border: 3px solid black !important;
}
.notruno {
  background-color: lightgrey !important;
  color : black !important;
}
.question {
  background-color: aquamarine !important;
  color : black !important;
  border: 3px solid limegreen !important;
}
.questiono {
  background-color: aquamarine !important;
  color : black !important;
}
.answer {
  background-color: navajowhite !important;
  border: 3px solid brown !important;
}
.answero {
  background-color: navajowhite !important;
  color : black !important;
}
.beyond {
  background-color: violet !important;
  border: 3px solid purple !important;
}
.beyondo {
  background-color: violet !important;
  color : black !important;
}
```


<!-- Hook to handle code blocks output folding -->

```{r knit_hook, echo = FALSE}
hooks = knitr::knit_hooks$get()
hook_foldable = function(type) {
  force(type)
  function(x, options) {
    res = hooks[[type]](x, options)
    
    if (isFALSE(options[[paste0("fold.", type)]])) return(res)
    
    paste0(
      "<details><summary>Show ", type, "</summary>\n\n",
      res,
      "\n\n</details>"
    )
  }
}
knitr::knit_hooks$set(
  output = hook_foldable("output"),
  plot = hook_foldable("plot")
)
```


------------------------------------------------------------------------

------------------------------------------------------------------------

<center>![](eb3i_banner.png)</center>

------------------------------------------------------------------------

------------------------------------------------------------------------

# PREAMBLE

## Purpose of this session

This file describes the different steps to perform the **first part** of
the **single cell RNAseq** data analysis training course for the **EBAII
n1 2025**, covering these steps :

-   **Load** a single cell raw counts **matrix**

-   **Remove** barcodes from **empty droplets**

-   **Estimate** and remove **ambient RNA** contamination *("soup")*

## An important notice

-   These early (but mandatory) steps of the analysis are not covered by
    the renowned, higher-level analysis frameworks like **Seurat** nor
    **scran/scater**.
    
-   Thus, we will write/use a certain amount of **lines of code**, some
    of which of a higher complexity for R beginners.
    
-   **Newcomer, do not fear** !

    -   While you are **welcome to try** writing some by yourself,
        depending on your R knowledge and self-confidence in it ...
        
    -   ... you do not have to know [**how**]{.underline} these code
        work ...
        
    -   ... thus you **should not feel ashamed** copy-pasting the
        pre-written code hereafter ...
        
    -   ... but in both cases, please try **your best understanding**
        [**what**]{.underline} these code do, and even more,
        [**why**]{.underline} !
        
    -   In this purpose, you may use whatever **help** you can **by**
        **searching**.

## What to run ?

-   This training presentation, written in Rmarkdown, contains **many** chunks ( = code blocks)

-   You **do not have to** run them all !

-   Chunks follow a **color code** :

### Chunks you **ARE** expected to run :

```{r chunk_run}
# chunk_run

## Example of a chunk to run
getwd()

```

<br>

### Chunks you **ARE NOT** expected to run

Hopefully, we will demo them. You may run them by yourself, young padawan, but if you get late or worst, break something, _you_'ll be the one to blame !

```{r chunk_demo, class.source="notrun", class.output="notruno"}
# chunk_demo

## Example of a chunk to NOT run
utils::sessionInfo()

```

<br>

### Questions

Some questions we would like you to answer during the training course.
Please be fair and do not take a look at the answer before we tell you so :)

```{r chunk_question, class.source="question", eval = FALSE}
# chunk_question

## What's the Answer to Life ? The Universe ? Everything ??

```

<br>

### Answers

They usually follow questions...

```{r chunk_answer, class.source = c("fold-hide", "answer"), class.output="answero"}
# chunk_answer

cat("The Answer to the Great Question... is ... 
Forty-two. Six by nine : forty-two. That's it. 
That's all there is. (I always thought something was 
fundamentally wrong with the universe.)")

```

<br>

### Additional exercises / questions

These are beyond the scope of the training course, but you may play it _if you feel bored_

```{r chunk_beyond, class.source="beyond", class.output="beyondo"}
# chunk_beyond

## Example of a chunk to play with but beyond the scope
getwd()

```

<br>

------------------------------------------------------------------------

------------------------------------------------------------------------


# Additional resources

**However**, some upcoming steps require a bit complicated methods that
are not fun to write, nor copy-paste multiple times. So, we will now
prepare code **functions** that will ease these steps. After executing
these functions code, we may call (invoke) them when needed.

## Functions

### SoupX helper function

This function was written to ease the use of SoupX on a Seurat object

It was tested on `SoupX`=1.6.2 with `igraph`=1.5.1, `Seurat`=4.4.0,5.1.0

Parameters :

-   `scmat_filt` : (sparse)matrix corresponding to an empty droplets -filtered count matrix

-   `scmat_raw` : (sparse)matrix corresponding to an NON- empty droplets -filtered count matrix

-   `soupQuantile`, `contaminationRange` : see `?SoupX::autoEstCont`

-   `contaminationRange` : range of the *expected* soup proportion

-   `soupRange` : estimate soup fraction from features with total reads
comprised in this range of counts (only used when `scmat_raw != NULL`)

-   `return_object` : if `TRUE`, return the "unsouped" `Seurat` object ; if
`FALSE`, only perform soup estimation and return the estimated
proportion value (rho)

-   `doPlot` : Perform the SoupX estimation plot (rho distribution)

```{r soupx_func, eval = TRUE}
# soupx_func

SoupX_auto <- function(scmat_filt = NULL, scmat_raw = NULL, soupQuantile = 0.9,
                       contaminationRange = c(.01, .8), soupRange = c(0,100),
                       return_object = FALSE, doPlot = FALSE) {
  
  ## Checks
  if(is.null(scmat_filt)) stop('A filtered count matrix is required !')
  
  if(is.null(scmat_raw)) message('No unfiltered raw counts matrix provided. Estimation will be based on filtered matrix only.')
  
  ## If no raw matrix
  if (is.null(scmat_raw)) {
    spChanRaw <- SoupX::SoupChannel(
      tod = scmat_filt, 
      toc = scmat_filt, 
      calcSoupProfile = FALSE)
    sc_rowsum <- sparseMatrixStats::rowSums2(scmat_filt)
    spProf <- data.frame(
      row.names = rownames(scmat_filt), 
      est = sc_rowsum/sum(scmat_filt), 
      counts = sc_rowsum)
    spChan <- SoupX::setSoupProfile(spChanRaw, spProf)
  } else {
    spChan <- SoupX::SoupChannel(
      tod = scmat_raw, 
      toc = scmat_filt, 
      calcSoupProfile = FALSE)
    if (min(spChan$nDropUMIs) > max(soupRange)) stop(
      'Minimum found counts per barcode is : ', 
      min(spChan$nDropUMIs), 
      ', which is smaller than the upper bound of soupRange ! Please increase soupRange max !')
    spChan <- SoupX::estimateSoup(sc = spChan, soupRange = soupRange)
  }
  ## Display Top 20 contributing genes
  if (!return_object) {
    cat('\nSoup-contributing features (Top 20) :\n')
    print(knitr::kable(head(
      spChan$soupProfile[order(spChan$soupProfile$est, decreasing = TRUE), ], 
      n = 20)))
  }
  ## Quick clustering needed
  spClust <- scran::quickCluster(scmat_filt, method = "igraph")
  ## Adding clusters to the SoupChannel object
  spChan <- SoupX::setClusters(sc = spChan, clusters = spClust)
  ## Estimating soup
  sX <- SoupX::autoEstCont(sc = spChan, doPlot = doPlot, tfidfMin = 1, 
                           soupQuantile = soupQuantile, maxMarkers = 100, 
                           contaminationRange = contaminationRange, 
                           rhoMaxFDR = .2, priorRho = .05, priorRhoStdDev = .1, 
                           forceAccept = FALSE)
  
  ## Removing soup (adjusting counts)
  if(return_object) {
    cat('Counts BEFORE SoupX : ', sum(scmat_filt), '\n')
    scmat_soupx <- SoupX::adjustCounts(
      sX, method = 'subtraction', roundToInt = TRUE, 
      tol = .001, pCut = .01)
    cat('Counts AFTER SoupX : ', sum(scmat_soupx), '\n')
    rm(scmat_filt)
    return(scmat_soupx)
  } else return(sX$fit$rhoEst)
}

```


<br>

------------------------------------------------------------------------

------------------------------------------------------------------------

# Start Rstudio

-   Using the [OpenOnDemand cheat
    sheet](https://ifb-elixirfr.github.io/EBAII/2023/ebaiin1/SingleCell/2024_TD_OpenOnDemand.html){target="_blank"} **[LINK_TO_UPDATE]**,
    connect to the [OpenOnDemand
    portal](https://ondemand.cluster.france-bioinformatique.fr){target="_blank"} and
    **create a Rstudio session** with the right resource requirements, thanks to the cheat sheet.

------------------------------------------------------------------------

------------------------------------------------------------------------

# Warm-up

-   We now set **common parameters** as new variables, once and for all for this
session :

```{r setparam}
# setparam


## Set your project name
# WARNING : Do not just copy-paste this ! It's MY project name ! Put YOURS !!
project_name <- "ebaii_sc_teachers"


## Control if the project_name exists on the cluster
cat('PATH CHECK : ', dir.exists(paste0('/shared/projects/', project_name)))

## Seed for the RNG
my_seed <- 1337L

## Empty droplets max p-value
max_p <- 1E-03

```

------------------------------------------------------------------------

------------------------------------------------------------------------

# Prepare the data structure [PREPROC.2]

## Main directory

```{r maindir}
# maindir

## Preparing the path
TD_dir <- paste0("/shared/projects/", project_name, "/SC_TD")

## Creating the root directory
dir.create(path = TD_dir, recursive = TRUE)

## Print the root directory on-screen
print(TD_dir)

```

## Current session

```{r sessiondir}
# sessiondir

## Creating the session (Preproc.2) directory
session_dir <- paste0(TD_dir, "/02_Preproc.2")
dir.create(path = session_dir, recursive = TRUE)

## Print the session directory on-screen
print(session_dir)

```

## Input directory

```{r indir}
# indir

## Creating the INPUT data directory
input_dir <- paste0(session_dir, "/DATA")
dir.create(path = input_dir, recursive = TRUE)

## Print the input directory on-screen
print(input_dir)

```

## Genelists directory

This is a directory where we will store additional information from 
knowledge bases about genes used to estimate the cell cycle phase of cells.

```{r resdir}
# resdir

res_dir <- paste0(TD_dir, "/Resources")
glist_dir <- paste0(res_dir, "/Genelists")

## Create the directory
dir.create(path = glist_dir, recursive = TRUE)

## Print the resources directory on-screen
print(glist_dir)

```

## Output directory

```{r outdir}
# outdir

## Creating the OUTPUT data directory
output_dir <- paste0(session_dir, "/RESULTS")
dir.create(path = output_dir, recursive = TRUE)

## Print the output directory on-screen
print(output_dir)

```


------------------------------------------------------------------------

------------------------------------------------------------------------

# Load the raw matrix [PreProc.2]

We retrieve the input data file

```{r mat_dl}
# mat_dl

local <- FALSE

## The raw count matrix we will start from
scmat_source <- "GSM4861194_gex_2_raw_gene_expression.tsv.gz"

## Download the file from Zenodo
if (!local) {
  
  ### ZenID
  zen_id <- "14033941"
  ### Zen Path
  zen_backup_file <- paste0("https://zenodo.org/records/",
                            zen_id,
                            "/files/",
                            scmat_source)
  
  ## The path to the locally saved input file
  scmat_file <- paste0(input_dir,
                       '/',
                       scmat_source)
  ## Download the file
  download.file(url = zen_backup_file,
                destfile = scmat_file)
} else {
  ebaii_session <- '2538_eb3i_n1_2025'
  scmat_file <- paste0(
      '/shared/projects/',
      ebaii_session,
      '/atelier_scrnaseq/TD/BACKUP/TSV/',
      scmat_source)
}
```

We can load it into R :

```{r mat_load}
# mat_load

## Loading the matrix directly as a sparseMatrix
scmat <- scuttle::readSparseCounts(
    file = scmat_file, 
    sep = "\t")

## Displaying its size in-memory (this is a basic matrix)
format(utils::object.size(scmat), units = "auto")

```


------------------------------------------------------------------------

------------------------------------------------------------------------

# Load the genelists resources [PreProc.2]

We retrieve the genelists

```{r gl_dl}
# gl_dl

local <- FALSE

## The genelist files
mito_source <- "mus_musculus_mito_symbols_20191015.rds"
ribo_source <- "mus_musculus_cribo_symbols_20191015.rds"
stress_source <- "mus_musculus_stress_symbols_20200224.rds"
gl_sources <- c(mito_source, ribo_source, stress_source)

## The (future) local files
mito_file <- paste0(input_dir, '/', mito_source)
ribo_file <- paste0(input_dir, '/', ribo_source)
stress_file <- paste0(input_dir, '/', stress_source)
gl_files <- c(mito_file, ribo_file, stress_file)

## Download the file from Zenodo
if (!local) {
  
  ### ZenID
  zen_id <- "14037355"
  ### Looping on files
  for (glf in seq_along(gl_sources)) {
    ### Zen Path
    zen_backup_file <- paste0("https://zenodo.org/records/",
                              zen_id,
                              "/files/",
                              gl_sources[glf])
    
    ## Download the file
    download.file(url = zen_backup_file,
                  destfile = gl_files[glf])
  }
  rm(gl_files)
} else {  ## Local mode
  ebaii_session <- '2538_eb3i_n1_2025'
  localbackup_dir <- paste0('/shared/projects/', ebaii_session, '/atelier_scrnaseq/TD/RESOURCES/GENELISTS/')
  mito_file <- paste0(localbackup_dir, '/mus_musculus_mito_symbols_20191015.rds')
  ribo_source <- paste0(input_dir, '/mus_musculus_cribo_symbols_20191015.rds')
  stress_source <- paste0(input_dir, '/mus_musculus_stress_symbols_20200224.rds')
}
```

------------------------------------------------------------------------

------------------------------------------------------------------------

# Reload the Seurat Object (example from PreProc.3)

-   We can reload the object we saved at the former step

```{r dataload}
# dataload

## The latest Seurat object saved as RDS (name)
sobj_file <- "02_TD3A_S5_Metrics.Bio_31053.4587.RDS"

## The latest Seurat object saved as RDS (full path)
sobj_path <- paste0(TD_dir, 
                    "/02_Preproc.2/RESULTS/",
                    sobj_file)

force <- FALSE  ## To force a re-download of a Zenodo-hosted backup
local <- FALSE  ## To force a loading from a local backup

## In case of error/lost data : force a reload from a Zenodo backup repository
if(force) {
  zen_id <- "14035293"
  zen_backup_file <- paste0("https://zenodo.org/records/",
                            zen_id,
                            "/files/",
                            sobj_file)
  ## Recreate the expected path if it does not exist
  dir.create(path = dirname(sobj_path), recursive = TRUE)
  ## Download the file
  download.file(url = zen_backup_file,
                destfile = sobj_path)
}

## In case of error/lost data : force a reload from a local backup repository
if(local) {
  sobj_path <- paste0(
    "/shared/projects/2422_ebaii_n1/atelier_scrnaseq/TD/BACKUP/RDS/",
    sobj_file)
}

## Load the object
sobj <- readRDS(file = sobj_path)

```

# Example of a set of tabs {.tabset .tabset-fade .tabset-pills}

## Tab One

-   Contains some text

    ```{r tab1chunk}
    # tab1chunk
    
    getwd()
    
    ```

## Tab Two

-   Contains some text too

    ```{r tab2chunk}
    # tab2chunk
    
    getwd()
    
    ```

#  {.unnumbered}

------------------------------------------------------------------------

------------------------------------------------------------------------

# Example of the "TEAMWORK" logo

That's what I use when trainees work in 5 binomes :

<br>
<CENTER>**TeAmWoRk TiMe !**
<br>
![](a2mibleufraise50.jpg)
</CENTER>
<br>


<br><br><br>

# Rsession

For reproducibility and context, it is recommended to include in your RMarkdown the list of loaded packages and their version.

```{r rsession, class.source="notrun", class.output="notruno"}
# rsession

utils::sessionInfo()

```
