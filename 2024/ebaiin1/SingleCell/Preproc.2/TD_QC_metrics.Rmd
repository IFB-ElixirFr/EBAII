---
title: "<CENTER>EB3I n1 2025 scRNAseq<BR>-<BR> <B>PRE-PROCESSING (II)</B><BR>-<BR>A nice subtitle</CENTER>"
date: "2025-16-21.22"
author:
  - name: "EBAII n1 scRNAseq Team"
  - name: "First AUTHOR"
    email: "first.author@scrnaseq.com"
  - name: "Second AUTHOR"
    email: "second.author@scrnaseq.com"
output:
  rmdformats::readthedown:
    fig_width: 8
    fig_height: 6
    highlight: tango  ## Theme for the code chunks
    embed_fonts: TRUE
    number_sections: true  ## Adds number to headers (sections)
    theme: flatly  ## CSS theme for the HTML page
    collapsed: true  ## By default, the TOC is folded
    toc_depth: 3
    smooth_scroll: true ## Smooth scroll of the HTML page
    self_contained: true ## Includes all plots/images within the HTML
    code_download: true ## Adds a button to download the Rmd
    code_folding: show
    thumbnails: false
    lightbox: true
    fig_caption: false
    gallery: true
    use_bookdown: true
always_allow_html: true ## Allow plain HTML code in the Rmd
editor_options: 
  markdown: 
    wrap: 72
---

<!-- knit setup -->

```{r knit_setup, echo = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,        # Print the code
  eval = TRUE,        # Run command lines
  message = FALSE,    # Print messages
  prompt = FALSE,     # Do not display prompt
  comment = NA,       # No comments on this section
  warning = FALSE,    # Display warnings
  tidy = FALSE,
  fig.align="center", 
  # results = 'hide',
  width = 100       # Number of characters per line
)
```


<!-- CSS to color chunks and outputs -->


```{css, echo=FALSE}
.notrun {
  background-color: lightgrey !important;
  border: 3px solid black !important;
}
.notruno {
  background-color: lightgrey !important;
  color : black !important;
}
.question {
  background-color: aquamarine !important;
  color : black !important;
  border: 3px solid limegreen !important;
}
.questiono {
  background-color: aquamarine !important;
  color : black !important;
}
.answer {
  background-color: navajowhite !important;
  border: 3px solid brown !important;
}
.answero {
  background-color: navajowhite !important;
  color : black !important;
}
.beyond {
  background-color: violet !important;
  border: 3px solid purple !important;
}
.beyondo {
  background-color: violet !important;
  color : black !important;
}
```


<!-- Hook to handle code blocks output folding -->

```{r knit_hook, echo = FALSE}
hooks = knitr::knit_hooks$get()
hook_foldable = function(type) {
  force(type)
  function(x, options) {
    res = hooks[[type]](x, options)
    
    if (isFALSE(options[[paste0("fold.", type)]])) return(res)
    
    paste0(
      "<details><summary>Show ", type, "</summary>\n\n",
      res,
      "\n\n</details>"
    )
  }
}
knitr::knit_hooks$set(
  output = hook_foldable("output"),
  plot = hook_foldable("plot")
)
```


------------------------------------------------------------------------

------------------------------------------------------------------------

<center>![](eb3i_banner.png)</center>

------------------------------------------------------------------------

------------------------------------------------------------------------


# Start Rstudio

-   Using the [OpenOnDemand cheat
    sheet](https://ifb-elixirfr.github.io/EBAII/2023/ebaiin1/SingleCell/2024_TD_OpenOnDemand.html){target="_blank"} **[LINK_TO_UPDATE]**,
    connect to the [OpenOnDemand
    portal](https://ondemand.cluster.france-bioinformatique.fr){target="_blank"} and
    **create a Rstudio session** with the right resource requirements, thanks to the cheat sheet.

------------------------------------------------------------------------

------------------------------------------------------------------------

# Warm-up

-   We now set **common parameters** as new variables, once and for all for this
session :

```{r setparam}
# setparam


## Set your project name
# WARNING : Do not just copy-paste this ! It's MY project name ! Put YOURS !!
project_name <- "ebaii_sc_teachers"


## Control if the project_name exists on the cluster
cat('PATH CHECK : ', dir.exists(paste0('/shared/projects/', project_name)))

## Seed for the RNG
my_seed <- 1337L

# ## Empty droplets max p-value
# max_p <- 1E-03

```

------------------------------------------------------------------------

------------------------------------------------------------------------

# Prepare the data structure 

## Main directory

```{r maindir}
# maindir

## Preparing the path
TD_dir <- paste0("/shared/projects/", project_name, "/SC_TD")

## Creating the root directory
# dir.create(path = TD_dir, recursive = TRUE)

## Print the root directory on-screen
print(TD_dir)

```

## Current session

```{r sessiondir}
# sessiondir

## Creating the session (Preproc.2) directory
session_dir <- paste0(TD_dir, "/02_Preproc.2")
# dir.create(path = session_dir, recursive = TRUE)

## Print the session directory on-screen
print(session_dir)

```

## Input directory

```{r indir}
# indir

## Creating the INPUT data directory
input_dir <- paste0(session_dir, "/DATA")
# dir.create(path = input_dir, recursive = TRUE)

## Print the input directory on-screen
print(input_dir)

```

## Genelists directory

This is a directory where we will store additional information from 
knowledge bases about genes used to estimate the cell cycle phase of cells.

```{r resdir}
# resdir

res_dir <- paste0(TD_dir, "/Resources")
glist_dir <- paste0(res_dir, "/Genelists")

## Create the directory
# dir.create(path = glist_dir, recursive = TRUE)

## Print the resources directory on-screen
print(glist_dir)

```

## Output directory

```{r outdir}
# outdir

## Creating the OUTPUT data directory
output_dir <- paste0(session_dir, "/RESULTS")
# dir.create(path = output_dir, recursive = TRUE)

## Print the output directory on-screen
print(output_dir)

```


------------------------------------------------------------------------

------------------------------------------------------------------------

# Load the raw matrix 

We retrieve the input data file

```{r mat_dl}
# mat_dl

local <- FALSE

## The raw count matrix we will start from
scmat_source <- "GSM4861194_gex_2_raw_gene_expression.tsv.gz"

## Download the file from Zenodo
if (!local) {
  
  ### ZenID
  zen_id <- "14033941"
  ### Zen Path
  zen_backup_file <- paste0("https://zenodo.org/records/",
                            zen_id,
                            "/files/",
                            scmat_source)
  
  ## The path to the locally saved input file
  scmat_file <- paste0(input_dir,
                       '/',
                       scmat_source)
  ## Download the file
  download.file(url = zen_backup_file,
                destfile = scmat_file)
} else {
  ebaii_session <- '2538_eb3i_n1_2025'
  scmat_file <- paste0(
      '/shared/projects/',
      ebaii_session,
      '/atelier_scrnaseq/TD/BACKUP/TSV/',
      scmat_source)
}
```

We can load it into R :

```{r mat_load}
# mat_load

scmat <- as.matrix(
  utils::read.table(
    file = scmat_file, 
    header = TRUE, 
    sep = "\t"))

## Displaying its size in-memory (this is a basic matrix)
format(utils::object.size(scmat), units = "auto")

```


------------------------------------------------------------------------

------------------------------------------------------------------------

# Load the genelists resources 

We retrieve the genelists

```{r gl_dl}
# gl_dl

local <- FALSE

## The genelist files
mito_source <- "mus_musculus_mito_symbols_20191015.rds"
ribo_source <- "mus_musculus_cribo_symbols_20191015.rds"
stress_source <- "mus_musculus_stress_symbols_20200224.rds"
gl_sources <- c(mito_source, ribo_source, stress_source)

## The (future) local files
mito_file <- paste0(input_dir, '/', mito_source)
ribo_file <- paste0(input_dir, '/', ribo_source)
stress_file <- paste0(input_dir, '/', stress_source)
gl_files <- c(mito_file, ribo_file, stress_file)

## Download the file from Zenodo
if (!local) {
  
  ### ZenID
  zen_id <- "14037355"
  ### Looping on files
  for (glf in seq_along(gl_sources)) {
    ### Zen Path
    zen_backup_file <- paste0("https://zenodo.org/records/",
                              zen_id,
                              "/files/",
                              gl_sources[glf])
    
    ## Download the file
    download.file(url = zen_backup_file,
                  destfile = gl_files[glf])
  }
  rm(gl_files)
} else {  ## Local mode
  ebaii_session <- '2538_eb3i_n1_2025'
  localbackup_dir <- paste0('/shared/projects/', ebaii_session, '/atelier_scrnaseq/TD/RESOURCES/GENELISTS/')
  mito_file <- paste0(localbackup_dir, '/mus_musculus_mito_symbols_20191015.rds')
  ribo_source <- paste0(input_dir, '/mus_musculus_cribo_symbols_20191015.rds')
  stress_source <- paste0(input_dir, '/mus_musculus_stress_symbols_20200224.rds')
}
```

------------------------------------------------------------------------

------------------------------------------------------------------------









---

**Description**:

This file describes the different steps to the quality control based on:

* the number of UMI (transcripts) detected per cell
* the number of genes detected per cell
* the proportion of transcripts related to the genes encoded in the mitochondria, per cell
* the proportion of transcripts related to the genes encoding ribosomal units, per cell
* the proportion of transcripts related to stress signature, per cell

**Input data**: Seurat object containing all cells (filtered count matrix)

**Output data**: Seurat object annotated for the cells to filter out for downstream analysis, called `sobj_TD3A_qc_annotated.rds`

**Next steps**: Cells annotation for cell type, doublet status and cell cycle status

# Context

In this file, we used a dataset from the [Paiva et al.](https://febs.onlinelibrary.wiley.com/doi/full/10.1111/febs.14651) publication.

The study concerns **thymus autonomy**:

* The thymus is an "organ of passage", critical in its function to the adaptive immune system for the maturation of T cell lymphocytes.
* This maturation involves two main steps, performed thanks to macrophages:
  * Positive selection : keeping cells that successfully develop react appropriately with MHC immune receptors of the body
  * Negative selection : keeping cells that do not react against natural proteins of the body.
* Thymus _autonomy_ is a natural mechanism that allows to create T cells in the thymus by differentiation and cell competition, even when normal progenitors from the bone marrow are lacking, in critical conditions.
* This mechanism is known in its effects, but the cells involved in are not.
* This study is of importance in the health field, as this mechanism relies on a temporary loss of control of the cell normal functions.
* The consequence is that if thymus is in autonomy for too long (few weeks), this is a prelude for leukemia !

  <center>![](thymus_autonomy.png)</center>

* Organism is : **mus musculus**
* Individuals are : mice **in development, grafted**
* The design corresponds to **two conditions** (Test / control)
  * Control : thymus from **wild type** newborn mouse transplanted into **wild type** juvenile mouse. In this control case, **donor** T-cells progenitors (DN3) were replaced by **host** cells **3 weeks** after transplantation.
  * Test : thymus from **wild type** newborn mouse transplanted in **KO Rag-/-** type juvenile mouse (the KO partially impairs their ability to produce T-cell progenitors in normal amounts). In this test case, **donor** T-cells progenitors (DN3) were replaced by **host** cells **9 weeks** after transplantation, showing that the donor DN3 cells outlived their normal lifespan by ~6 weeks.
  
  <center>![](paiva_wt_ko.png)</center>
  

You will mainly work on the **KO sample ('TD3A')**. The input data consists in a **count matrix**, as a gzipped tabular text file, that contains everything needed to create a basic Seurat object :
  * The expressions **counts**
  * The **feature names** (here, gene symbols)
  * The **barcode names**

This matrix has already been **filtered for empty droplets**.

<!-- # Pre-requisites -->

<!-- To obtain this file and starts the TD, copy-paste the folder in your project, either using the graphical interface, or in the Terminal: -->



<!-- The tree should looks like: -->

<!-- ```{bash} -->
<!-- ls -->
<!-- ``` -->

# Environment

We load the package of interest:

```{r packages, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(Seurat)

.libPaths()
```

# Data

We load the count matrix:

```{r load_count_matrix}
# # Set input data
# input_data = "/shared/projects/2538_eb3i_n1_2025/atelier_scrnaseq/TD/BACKUP/TSV/GSM4861194_gex_2_raw_gene_expression.tsv.gz"
# 
# # Load data
# mat = read.table(input_data,
#                  header = TRUE,
#                  sep = "\t")
# mat = as.matrix(mat)
# mat = Matrix::Matrix(mat,
#                      sparse = TRUE)

dim(scmat)
scmat[c(1:5), c(1:5)]
```

We build a Seurat object from the count matrix:

```{r make_sobj}
sobj = Seurat::CreateSeuratObject(counts = scmat,
                                  assay = "RNA",
                                  project = "TD3A")
sobj
```

We do not need the count matrix:

```{r rm_mat}
rm(scmat)
```


<!-- # Global settings -->

<!-- We define the output directory to save the Seurat object in this end of this file: -->

<!-- ```{r outdir, eval=FALSE} -->
<!-- outdir = "./data" -->

<!-- if (!dir.exists(outdir)) { -->
<!--   dir.create(outdir, recursive = FALSE) -->
<!-- } -->
<!-- ``` -->

We set the filtering thresholds based on quality control-related metrics. Adjust them as necessary based on the figures.

```{r set_thresholds}
cut_nCount_RNA = 300
cut_log10_nCount_RNA <- 3
cut_nFeature_RNA = 750
cut_percent_mt = 5
cut_percent_rb = 30
cut_percent_st = 6
```

We define a nice palette to visualize the QC metrics:

```{r color_palette}
color_palette = c("lightgray", "#FDBB84", "#EF6548", "#7F0000", "black")
```


For the QC metrics related to the proportion of UMI belongs to a specific gene sets, we need to load the gene sets.

```{r load_lists}
mito_symbols = readRDS(mito_file)
mito_symbols

ribo_symbols = readRDS(ribo_file)
ribo_symbols

stress_symbols = readRDS(stress_file)
stress_symbols
```

We keep only the gene symbols available in our data:

```{r subset_symbols}
mito_symbols = intersect(mito_symbols, rownames(sobj))
mito_symbols

ribo_symbols = intersect(ribo_symbols, rownames(sobj))
ribo_symbols

stress_symbols = intersect(stress_symbols, rownames(sobj))
stress_symbols
```

**Note**: A more robust analysis may use the gene identifiers instead of gene symbols.

# Fast-processing

To visualize the low quality cells, we generate a projection. Understanding the commands below is the purpose of next course sessions. So just run:

```{r quick_processing, message=FALSE, warning=FALSE}
sobj = Seurat::NormalizeData(sobj)
sobj = Seurat::ScaleData(sobj)
sobj = Seurat::FindVariableFeatures(sobj)
sobj = Seurat::RunPCA(sobj)
sobj = Seurat::RunUMAP(sobj, dims = c(1:20))

sobj
```

We can now visualize the cells on a 2D projection:

```{r visualize_cells, fig.width = 8, fig.height = 8}
Seurat::DimPlot(sobj,
                reduction = "umap",
                cols = "black")
```

# Quality control

## Compute metrics

What is already available in the Seurat object ?

```{r see_metadata}
head(sobj@meta.data)
```

How do the two first QC metrics vary ?

```{r summary_metadata}
summary(sobj@meta.data)
```

In the column `nCount_RNA`, the maximum is far from the third quartile. For visualization purpose, we transform this column to log10 scale.

```{r log10_ncount_RNA}
sobj$log10_nCount_RNA = log10(sobj$nCount_RNA)

summary(sobj@meta.data)
```

We compute the percentage of UMI related for each of the three list of genes. First, we compute the proportion of transcripts related to the genes encoded in the mitochondria, per cell.

```{r percent_mt}
sobj = Seurat::PercentageFeatureSet(
  sobj,
  assay = "RNA",
  features = mito_symbols,
  col.name = "percent_mt")

# # Alternative way to do (almost) the same:
# sobj = Seurat::PercentageFeatureSet(
#   sobj,
#   assay = "RNA",
#   pattern = "^mt-",
#   col.name = "percent_mt")

summary(sobj$percent_mt)
```

Then, we compute the proportion of transcripts related to the genes encoding ribosomal units, per cell:

```{r percent_rb}
sobj = Seurat::PercentageFeatureSet(
  sobj,
  assay = "RNA",
  features = ribo_symbols,
  col.name = "percent_rb")

# # Alternative way to do (almost) the same:
# sobj = Seurat::PercentageFeatureSet(
#   sobj,
#   assay = "RNA",
#   pattern = "^Rp[l|s][a-z]?[0-9]*[a,x]?$",
#   col.name = "percent_rb")

summary(sobj$percent_rb)
```


Finally, we compute the proportion of transcripts related to stress signature, per cell:

```{r percent_st}
sobj = Seurat::PercentageFeatureSet(
  sobj,
  assay = "RNA",
  features = stress_symbols,
  col.name = "percent_st")

summary(sobj$percent_st)
```


We know have all the QC-related metrics:

```{r final_summary}
summary(sobj@meta.data)
```

## Failing cells

We identify the cells that do not pass the quality control. This will be used for the visualization and for filtering. If the filtering thresholds are modified, do not forget to run again this chunk.

```{r fail_cells}
fail_percent_mt = sobj@meta.data %>%
  dplyr::filter(percent_mt > cut_percent_mt) %>%
  rownames()

fail_percent_rb = sobj@meta.data %>%
  dplyr::filter(percent_rb > cut_percent_rb) %>%
  rownames()

fail_percent_st = sobj@meta.data %>%
  dplyr::filter(percent_st > cut_percent_st) %>%
  rownames()

fail_nCount_RNA = sobj@meta.data %>%
  dplyr::filter(nCount_RNA < cut_nCount_RNA) %>%
  rownames()

fail_nFeature_RNA = sobj@meta.data %>%
  dplyr::filter(nFeature_RNA < cut_nFeature_RNA) %>%
  rownames()
```

## Visualization

This is difficult to handle the distribution of these metrics across cells. We opt for various visualization ways:

* **histogram**, showing the distribution of the metric
* **violin/box plot**, showing the distribution of the metric, useful if several datasets are considered
* **UMAP** (or alternatively, tSNE), showing the distribution of the metric over a 2D projection of cells

You may choose one of these visualization ways.

### Number of UMI

#### Define the code

We write a lot of code to create our figures of interest:

```{r define_code, fig.width = 18, fig.height = 4}
# Histogram showing:
# - the distribution of the metric
# - an estimated density
# - the filtering threshold as a straight line
p_hist = ggplot(sobj@meta.data, aes(x = log10_nCount_RNA)) +
  geom_histogram(aes(y = after_stat(density)),
                          colour = "black", fill = "#F8766D", bins = 100) +
  geom_density(alpha = 0, col = "blue", lwd = 0.75) +
  geom_vline(xintercept = cut_log10_nCount_RNA, col = "red") +
  labs(title = paste0("Threshold for log10_nCount_RNA is: ", cut_log10_nCount_RNA)) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))

# Violin plot:
# - is easily accessible in the Seurat package
# - can or not display the cells (set `pt.size = 0` to hide the cells)
# - is useful when several datasets have been merged
p_violin = Seurat::VlnPlot(sobj, features = "log10_nCount_RNA") +
  geom_hline(yintercept = cut_log10_nCount_RNA, col = "red") +
  theme(axis.title.x = element_blank(),
                 legend.position = "none")

# # Box plot is similar to violin plot but not in the Seurat package
# p_boxplot = ggplot(sobj@meta.data, aes(y = log10_nCount_RNA,
#                                                 x = orig.ident)) +
#   geom_boxplot(colour = "black", fill = "#F8766D") +
#   geom_jitter(width = 0.3, size = 0.001) +
#   geom_hline(yintercept = cut_log10_nCount_RNA, col = "red") +
#   theme_classic() +
#   theme(axis.title.x = element_blank())

# This 2D representation shows the distribution of the metric over cells
p_umap = FeaturePlot(sobj,
                     reduction = "umap",
                     features = "log10_nCount_RNA") +
  scale_color_gradientn(colors = color_palette) +
  theme(aspect.ratio = 1)

# This 2D representation shows the low quality cells in color
# `order = "fail"` is used to display failing cells on front
# before, we need to define the "failorpass" column in sobj@meta.data
# It corresponds to "fail" for cells that do no pass the threshold,
# or "pass" otherwise
sobj$failorpass = ifelse(colnames(sobj) %in% fail_nCount_RNA,
                         yes = "fail", no = "pass") %>%
  as.factor()

p_fail = DimPlot(sobj,
                 group.by = "failorpass",
                 order = "fail") +
  scale_color_manual(values = c("#F8766D", "gray80"),
                     breaks = levels(sobj$failorpass)) +
  labs(title = "log10_nCount_RNA",
       subtitle = paste0(length(fail_nCount_RNA), " cells fail (",
                         round(100*length(fail_nCount_RNA)/ncol(sobj), 2), " %)")) +
  theme(aspect.ratio = 1,
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))

sobj$failorpass = NULL # remove the column (it was temporary)

# We use the patchwork package to arrange all figures together
patchwork::wrap_plots(p_umap, p_fail, p_hist, p_violin) +
  patchwork::plot_layout(nrow = 1, widths = c(1, 1, 2, 1))
```

#### Define a function

Instead of copying-pasting this section of code for all QC-metrics, we design a function using the template below:

```{r my_function_name, eval = FALSE}
my_function_name = function(param1, param2) {
  # do something with the parameter values
  output = "something"
  
  return(output)
}
```

Here is the function:

```{r qc_print_function}
print_1_qc_metric = function(object = sobj,
                             qc = "log10_nCount_RNA",
                             cut_qc = cut_log10_nCount_RNA,
                             failing_cells = fail_nCount_RNA) {
  # Description of the parameters:
  # - sobj : the Seurat object, with default value to the one
  # - qc : CHARACTER : the QC metric, must be a column in sobj@meta.data
  # - cut_qc : NUMERIC : the filtering threshold for the QC metric
  # - failing_cells : CHARACTER VECTOR : the cells that fail the QC
  
  # Histogram
  p_hist = ggplot(object@meta.data, aes(x = .data[[qc]])) +
    geom_histogram(aes(y = after_stat(density)),
                            colour = "black", fill = "#F8766D", bins = 100) +
    geom_density(alpha = 0, col = "blue", lwd = 0.75) +
    geom_vline(xintercept = cut_qc, col = "red") +
    labs(title = paste0("Threshold for ", qc, " is: ", cut_qc)) +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5))
  
  # Violin plot
  p_violin = Seurat::VlnPlot(object, features = qc) +
    geom_hline(yintercept = cut_qc, col = "red") +
    theme(axis.title.x = element_blank(),
                   legend.position = "none")
  
  # Box plot
  p_boxplot = ggplot(object@meta.data, aes(y = .data[[qc]],
                                                    x = "orig.ident")) +
    geom_boxplot(colour = "black", fill = "#F8766D") +
    geom_jitter(width = 0.3, size = 0.001) +
    geom_hline(yintercept = cut_qc, col = "red") +
    theme_classic() +
    theme(axis.title.x = element_blank())
  
  # Feature plot
  p_umap = Seurat::FeaturePlot(object,
                               reduction = "umap",
                               features = qc) +
    scale_color_gradientn(colors = color_palette) +
    theme(aspect.ratio = 1)
  
  # Dim plot
  object$failorpass = ifelse(colnames(object) %in% failing_cells,
                             yes = "fail", no = "pass") %>%
    as.factor()
  
  p_fail = Seurat::DimPlot(object,
                           group.by = "failorpass",
                           order = "fail") +
    scale_color_manual(values = c("#F8766D", "gray80"),
                                breaks = levels(object$failorpass)) +
    labs(title = qc,
                  subtitle = paste0(length(failing_cells), " cells fail (",
                                    round(100*length(failing_cells)/ncol(sobj), 2), " %)")) +
    theme(aspect.ratio = 1,
                   plot.title = element_text(hjust = 0.5),
                   plot.subtitle = element_text(hjust = 0.5))
  
  # Patchwork
  p = patchwork::wrap_plots(p_umap, p_fail, p_hist, p_violin, p_boxplot) +
    patchwork::plot_layout(nrow = 1, widths = c(1, 1, 2, 1, 1))
  
  return(p)
}
```

#### Check the function

This is working for `log10_nCount_RNA`, because it is used to define default parameter values:

```{r check1_log10_nCount_RNA, fig.width = 18, fig.height = 4}
print_1_qc_metric()
```

but also works by specifying the parameter values:

```{r check2_log10_nCount_RNA, fig.width = 18, fig.height = 4}
print_1_qc_metric(sobj,
                  qc = "log10_nCount_RNA",
                  cut_qc = cut_log10_nCount_RNA,
                  failing_cells = fail_nCount_RNA)
```

So we can copy-paste only this chunk for the next QC metrics !

### Number of genes

```{r see_nFeature_RNA, fig.width = 18, fig.height = 4}
print_1_qc_metric(sobj,
                  qc = "nFeature_RNA",
                  cut_qc = cut_nFeature_RNA,
                  failing_cells = fail_nFeature_RNA)
```

### Mitochondrial genes expression

```{r see_percent_mt, fig.width = 18, fig.height = 4}
print_1_qc_metric(sobj,
                  qc = "percent_mt",
                  cut_qc = cut_percent_mt,
                  failing_cells = fail_percent_mt)
```

### Ribosomal genes expression

```{r see_percent_rb, fig.width = 18, fig.height = 4}
print_1_qc_metric(sobj,
                  qc = "percent_rb",
                  cut_qc = cut_percent_rb,
                  failing_cells = fail_percent_rb)
```

### Stress-related genes expression

```{r see_percent_st, fig.width = 18, fig.height = 4}
print_1_qc_metric(sobj,
                  qc = "percent_st",
                  cut_qc = cut_percent_st,
                  failing_cells = fail_percent_st)
```

# Filtering

We could filter out cells based on these 5 QC metrics now. It is also possible to wait, perform various annotations such as cell type annotation or cell cycle phase scoring, to better characterize the low quality cells.

To filter a Seurat object, we use the `subset` function:

```{r filter_sobj}
sobj_filtered = subset(sobj, invert = TRUE,
                       cells = unique(c(fail_nCount_RNA, fail_nFeature_RNA,
                                        fail_percent_mt, fail_percent_rb, fail_percent_st)))
sobj_filtered
```

We are going to save the object annotated for cells that fail the quality control, regardless the metrics. So we add a single column to `sobj@meta.data` :

```{r add_fail_qc}
sobj$fail_qc = ifelse(test = colnames(sobj) %in% colnames(sobj_filtered),
                      yes = "pass",
                      no = "fail")

table(sobj$fail_qc)
```


# Save

We save the non-filtered Seurat object:

```{r save_sobj, eval=FALSE}
saveRDS(sobj, file = paste0(output_dir, "/sobj_TD3A_qc_annotated.rds"))
```

This Seurat object can then be the input object for annotation, definition of a new projection and downstream analyses.

# R session

This is a good practice to show the version of the packages used in this notebook.

```{r sessioninfo, class.source = "fold-hide"}
sessionInfo()
```

